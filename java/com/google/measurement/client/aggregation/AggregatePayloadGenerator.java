/*
 * Copyright (C) 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.measurement.client.aggregation;

import com.google.measurement.client.Flags;
import com.google.measurement.client.FilterMap;
import com.google.measurement.client.Source;
import com.google.measurement.client.Trigger;
import com.google.measurement.client.XNetworkData;
import com.google.measurement.client.util.Filter;
import com.google.measurement.client.util.UnsignedLong;

import java.util.Map;
import org.json.JSONException;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.TreeMap;
import java.util.stream.IntStream;

/**
 * Class used to generate AggregateReport using AggregatableAttributionSource and
 * AggregatableAttributionTrigger.
 */
public class AggregatePayloadGenerator {
  private final Flags mFlags;

  public AggregatePayloadGenerator(Flags flags) {
    mFlags = flags;
  }

  /**
   * Generates the {@link AggregateReport} from given AggregatableAttributionSource and
   * AggregatableAttributionTrigger.
   *
   * @param source the aggregate attribution source used for aggregation.
   * @param trigger the aggregate attribution trigger used for aggregation.
   * @return the aggregate report generated by the given aggregate attribution source and aggregate
   *     attribution trigger.
   */
  public Optional<List<AggregateHistogramContribution>> generateAttributionReport(
      Source source, Trigger trigger) throws JSONException {
    Optional<AggregatableAttributionSource> aggregateAttributionSource =
        source.getAggregatableAttributionSource(trigger, mFlags);
    Optional<AggregatableAttributionTrigger> aggregateAttributionTrigger =
        trigger.getAggregatableAttributionTrigger(mFlags);
    if (aggregateAttributionSource.isEmpty() || aggregateAttributionTrigger.isEmpty()) {
      return Optional.empty();
    }

    AggregatableAttributionSource attributionSource = aggregateAttributionSource.get();
    AggregatableAttributionTrigger attributionTrigger = aggregateAttributionTrigger.get();

    FilterMap sourceFilterMap = attributionSource.getFilterMap();
    TreeMap<String, BigInteger> aggregateSourceMap = attributionSource.getAggregatableSource();
    Filter filter = new Filter(mFlags);
    for (AggregateTriggerData triggerData : attributionTrigger.getTriggerData()) {
      Optional<List<FilterMap>> filterSet = triggerData.getFilterSet();
      Optional<List<FilterMap>> notFilterSet = triggerData.getNotFilterSet();
      // Skip this trigger data when filter doesn't match.
      if (filterSet.isPresent() && !filter.isFilterMatch(sourceFilterMap, filterSet.get(), true)) {
        continue;
      }
      // Skip this trigger data when not_filters doesn't match.
      if (notFilterSet.isPresent()
          && !filter.isFilterMatch(sourceFilterMap, notFilterSet.get(), false)) {
        continue;
      }

      final BigInteger triggerDataKey;
      Optional<BigInteger> keyMappingForAdtech =
          Optional.ofNullable(trigger.parseAdtechKeyMapping())
              // Derived source has parent source's enrollment ID
              .map(map -> map.get(source.getEnrollmentId()));
      if (source.getParentId() != null && keyMappingForAdtech.isPresent()) {
        int keyOffset =
            triggerData
                .getXNetworkData()
                .flatMap(XNetworkData::getKeyOffset)
                .map(UnsignedLong::getValue)
                .map(Long::intValue)
                .orElse(0);

        BigInteger orValue = keyMappingForAdtech.get().shiftLeft(keyOffset);
        triggerDataKey = triggerData.getKey().or(orValue);
      } else {
        triggerDataKey = triggerData.getKey();
      }

      for (String sourceKey : triggerData.getSourceKeys()) {
        aggregateSourceMap.computeIfPresent(sourceKey, (k, v) -> v.or(triggerDataKey));
      }
    }

    List<AggregateHistogramContribution> contributions = new ArrayList<>();
    Optional<Map<String, Integer>> maybeMatchedValueMap =
        getMatchedValueMap(attributionTrigger, sourceFilterMap, filter);
    if (maybeMatchedValueMap.isPresent()) {
      for (String id : aggregateSourceMap.navigableKeySet()) {
        if (maybeMatchedValueMap.get().containsKey(id)) {
          contributions.add(
              buildContribution(aggregateSourceMap.get(id), maybeMatchedValueMap.get().get(id)));
        }
      }
    }
    if (contributions.size() > 0) {
      if (mFlags.getMeasurementEnableAggregatableReportPayloadPadding()) {
        AggregateHistogramContribution paddingContribution =
            new AggregateHistogramContribution.Builder().setPaddingContribution().build();

        padContributions(contributions, paddingContribution);
      }
      return Optional.of(contributions);
    }
    return Optional.empty();
  }

  /**
   * Given a list of {@link AggregateHistogramContribution} actual contributions and a single {@link
   * AggregateHistogramContribution} padding contribution, append the maximum number of padding
   * contributions to the actual attributions, in place. The maximum number of contributions is
   * defined in the flags. If the number of actual contributions is already at the maximum limit,
   * then do nothing.
   *
   * @param contributions actual contributions
   * @param padding the contribution that will act as the pad value.
   */
  public void padContributions(
      List<AggregateHistogramContribution> contributions, AggregateHistogramContribution padding) {
    IntStream.range(
            contributions.size(), mFlags.getMeasurementMaxAggregateKeysPerSourceRegistration())
        .forEach(i -> contributions.add(padding));
  }

  /**
   * Returns first matched value map from getValueConfigs against Source filters or value map from
   * getValues.
   */
  public Optional<Map<String, Integer>> getMatchedValueMap(
      AggregatableAttributionTrigger aggregatableAttributionTrigger,
      FilterMap sourceFilterMap,
      Filter filter) {
    if (aggregatableAttributionTrigger.getValueConfigs() != null) {
      for (AggregatableValuesConfig aggregatableValuesConfig :
          aggregatableAttributionTrigger.getValueConfigs()) {
        boolean matchedFilters =
            aggregatableValuesConfig.getFilterSet() == null
                ? true
                : filter.isFilterMatch(
                    sourceFilterMap, aggregatableValuesConfig.getFilterSet(), true);
        if (!matchedFilters) {
          continue;
        }
        boolean matchedNotFilters =
            aggregatableValuesConfig.getNotFilterSet() == null
                ? true
                : filter.isFilterMatch(
                    sourceFilterMap, aggregatableValuesConfig.getNotFilterSet(), false);
        if (matchedNotFilters) {
          return Optional.of(aggregatableValuesConfig.getConfigValuesMap());
        }
      }
    }
    return Optional.empty();
  }

  /** Add a new contribution with key, value to the existing list of contributions. */
  private AggregateHistogramContribution buildContribution(BigInteger key, int value) {
    return new AggregateHistogramContribution.Builder().setKey(key).setValue(value).build();
  }
}
